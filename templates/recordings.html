{% extends "base.html" %}

{% block title %}
Recordings
{% endblock %}

{% block content %}
<div class="container mt-4">
    <h1 class="text-center mb-4">Recordings</h1>
    <p class="text-center text-muted mb-4">View and manage your recorded videos here.</p>
    
    <!-- Normal Recordings Section -->
    <div class="section-container mb-5">
        <div class="section-header">
            <h2 class="section-title">
                <i class="fas fa-video me-2"></i>
                Normal Recordings
            </h2>
            <p class="section-subtitle text-muted">Raw video recordings from the live feed</p>
        </div>
        
        <div class="row" id="normalRecordingsList">
            <!-- Normal recordings will be loaded here -->
        </div>
    </div>

    <!-- Divider -->
    <div class="section-divider">
        <hr class="divider-line">
        <div class="divider-content">
            <i class="fas fa-circle"></i>
        </div>
    </div>

    <!-- Segmented Recordings Section -->
    <div class="section-container">
        <div class="section-header">
            <h2 class="section-title">
                <i class="fas fa-cut me-2"></i>
                Segmented Recordings
            </h2>
            <p class="section-subtitle text-muted">Processed recordings with object detection and segmentation</p>
        </div>
        
        <div class="row" id="segmentedRecordingsList">
            <!-- Segmented recordings will be loaded here -->
        </div>
    </div>
</div>

<script>
// Check browser codec compatibility on page load
function checkCodecSupport() {
    const video = document.createElement('video');
    const codecSupport = {
        'H.264 Baseline (avc1.42E01E)': video.canPlayType('video/mp4; codecs="avc1.42E01E"'),
        'H.264 Main (avc1.4D401E)': video.canPlayType('video/mp4; codecs="avc1.4D401E"'), 
        'H.264 High (avc1.64001E)': video.canPlayType('video/mp4; codecs="avc1.64001E"'),
        'Generic MP4': video.canPlayType('video/mp4'),
        'AVI': video.canPlayType('video/x-msvideo')
    };
    
    console.log('Browser codec support check:', codecSupport);
    
    // Check if any H.264 codecs are supported
    const h264Support = Object.entries(codecSupport)
        .filter(([codec, _]) => codec.includes('H.264'))
        .some(([_, support]) => support !== '');
    
    if (!h264Support) {
        console.warn('⚠️ Limited H.264 codec support detected. Video playback may have issues.');
    } else {
        console.log('✅ H.264 codec support detected. Video playback should work well.');
    }
    
    return codecSupport;
}

function formatDate(timestamp) {
    const date = new Date(timestamp);
    return date.toLocaleString();
}

function loadRecordings() {
    fetch('/list_recordings')
        .then(r => r.json())
        .then(data => {
            const normalContainer = document.getElementById('normalRecordingsList');
            const segmentedContainer = document.getElementById('segmentedRecordingsList');
            
            // Clear both containers
            normalContainer.innerHTML = '';
            segmentedContainer.innerHTML = '';
            
            if (data.files.length === 0 && (!data.processing || data.processing.length === 0)) {
                normalContainer.innerHTML = `
                    <div class="col-12 text-center">
                        <div class="alert alert-info">
                            <i class="fas fa-info-circle me-2"></i>
                            No normal recordings found.
                        </div>
                    </div>`;
                    
                segmentedContainer.innerHTML = `
                    <div class="col-12 text-center">
                        <div class="alert alert-info">
                            <i class="fas fa-info-circle me-2"></i>
                            No segmented recordings found.
                        </div>
                    </div>`;
            } else {
                // Separate files into normal and segmented recordings
                const normalFiles = data.files.filter(file => !file.startsWith('segmented_recordings/'));
                const segmentedFiles = data.files.filter(file => file.startsWith('segmented_recordings/'));
                const processingFiles = data.processing || [];
                
                // Load normal recordings
                if (normalFiles.length === 0) {
                    normalContainer.innerHTML = `
                        <div class="col-12 text-center">
                            <div class="alert alert-info">
                                <i class="fas fa-info-circle me-2"></i>
                                No normal recordings found.
                            </div>
                        </div>`;
                } else {
                    normalFiles.forEach(function(file) {
                        const col = createRecordingCard(file, 'normal');
                        normalContainer.appendChild(col);
                    });
                }
                
                // Load segmented recordings
                let segmentedContent = '';
                if (segmentedFiles.length === 0 && processingFiles.length === 0) {
                    segmentedContainer.innerHTML = `
                        <div class="col-12 text-center">
                            <div class="alert alert-info">
                                <i class="fas fa-info-circle me-2"></i>
                                No segmented recordings found.
                            </div>
                        </div>`;
                } else {
                    // Add processing files
                    processingFiles.forEach(function(file) {
                        const col = createProcessingCard(file);
                        segmentedContainer.appendChild(col);
                    });
                    
                    // Only show processed segmented recordings that are NOT currently processing
                    const processedSegmentedFiles = segmentedFiles.filter(segFile => {
                        // The processed file is in format: 'segmented_recordings/Segmented Recording 2025-06-01 __ 08-03-46_PM.mp4'
                        // The corresponding processing file could be: 'Raw Segmented Recording 2025-06-01 __ 08-03-46_PM.mp4'
                        // Extract the base name from the segmented file
                        let baseName = segFile.replace('segmented_recordings/', '');
                        
                        // Check if any processing file corresponds to this segmented file
                        const isProcessing = processingFiles.some(procFile => {
                            // Handle different raw file formats
                            let procBaseName = procFile;
                            if (procFile.startsWith('raw_segmented_recording_')) {
                                procBaseName = procFile.replace('raw_segmented_recording_', 'Segmented Recording ');
                            } else if (procFile.startsWith('Raw Segmented Recording ')) {
                                procBaseName = procFile.replace('Raw ', '');
                            }
                            
                            return procBaseName === baseName;
                        });
                        
                        return !isProcessing;
                    });
                    processedSegmentedFiles.forEach(function(file) {
                        const col = createRecordingCard(file, 'segmented');
                        segmentedContainer.appendChild(col);
                    });
                }

                // Add event listeners for delete buttons
                document.querySelectorAll('.delete-button').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const filename = this.dataset.filename;
                        if (confirm(`Are you sure you want to delete ${filename}?`)) {
                            deleteRecording(filename);
                        }
                    });
                });
            }
        })
        .catch(error => {
            console.error('Error loading recordings:', error);
            const normalContainer = document.getElementById('normalRecordingsList');
            const segmentedContainer = document.getElementById('segmentedRecordingsList');
            
            const errorMessage = `
                <div class="col-12 text-center">
                    <div class="alert alert-danger">
                        <i class="fas fa-exclamation-circle me-2"></i>
                        Error loading recordings. Please try again later.
                    </div>
                </div>`;
                
            normalContainer.innerHTML = errorMessage;
            segmentedContainer.innerHTML = errorMessage;
        });
}

function createRecordingCard(file, type) {
    const col = document.createElement('div');
    col.className = 'col-md-6 mb-4';
    
    // Add type-specific styling
    const cardClass = type === 'segmented' ? 'card h-100 shadow-sm segmented-card' : 'card h-100 shadow-sm normal-card';
    const typeIcon = type === 'segmented' ? '<i class="fas fa-cut me-1"></i>' : '<i class="fas fa-video me-1"></i>';
    
    // Clean up display name - remove folder path for segmented recordings
    const displayName = file.startsWith('segmented_recordings/') ? file.replace('segmented_recordings/', '') : file;
    
    // Test video URL before creating the card
    const videoUrl = `/recordings/${encodeURIComponent(file)}`;
    console.log('Creating card for video:', file, 'Display name:', displayName, 'URL:', videoUrl);
    
    // Test if the video URL is accessible
    testVideoUrl(videoUrl).then(isAccessible => {
        console.log('Video URL accessible:', isAccessible, 'for file:', file);
        if (!isAccessible) {
            console.warn('Video URL not accessible:', videoUrl);
        }
    });
    
    col.innerHTML = `
        <div class="${cardClass}">
            <div class="card-body d-flex flex-column">
                <h5 class="card-title text-truncate mb-2" title="${displayName}">
                    ${typeIcon}${displayName}
                </h5>
                <div class="video-preview mb-3 flex-grow-1">
                    <video class="w-100 rounded" controls preload="metadata" 
                           onerror="handleVideoError(this, '${file}')" 
                           onloadedmetadata="handleVideoLoaded(this, '${file}')"
                           oncanplay="handleVideoCanPlay(this, '${file}')"
                           onloadstart="console.log('Video load started: ${file}')"
                           onloadeddata="console.log('Video data loaded: ${file}')"
                           onstalled="console.log('Video stalled: ${file}')"
                           onsuspend="console.log('Video suspended: ${file}')"
                           onabort="console.log('Video aborted: ${file}')"
                           onemptied="console.log('Video emptied: ${file}')">
                        <!-- H.264 baseline profile - most compatible with Chrome -->
                        <source src="/recordings/${encodeURIComponent(file)}?t=${Date.now()}" 
                                type='video/mp4; codecs="avc1.42E01E"' 
                                onerror="handleSourceError(this, '${file}', 'H.264 Baseline')" />
                        <!-- H.264 main profile - good compatibility -->
                        <source src="/recordings/${encodeURIComponent(file)}?t=${Date.now()}" 
                                type='video/mp4; codecs="avc1.4D401E"' 
                                onerror="handleSourceError(this, '${file}', 'H.264 Main')" />
                        <!-- H.264 high profile - highest quality -->
                        <source src="/recordings/${encodeURIComponent(file)}?t=${Date.now()}" 
                                type='video/mp4; codecs="avc1.64001E"' 
                                onerror="handleSourceError(this, '${file}', 'H.264 High')" />
                        <!-- Generic MP4 fallback -->
                        <source src="/recordings/${encodeURIComponent(file)}?t=${Date.now()}" 
                                type="video/mp4" 
                                onerror="handleSourceError(this, '${file}', 'Generic MP4')" />
                        <!-- Legacy AVI fallback -->
                        <source src="/recordings/${encodeURIComponent(file)}?t=${Date.now()}" 
                                type="video/x-msvideo" 
                                onerror="handleSourceError(this, '${file}', 'AVI')" />
                        <p class="text-danger p-3">
                            <i class="fas fa-exclamation-triangle me-2"></i>
                            Your browser does not support video playback or the video format is not compatible.
                            <br><small>This may be due to codec compatibility issues with Chrome. Try downloading the video to play it with an external player.</small>
                        </p>
                    </video>
                    <div class="video-error-info" style="display: none;">
                        <small class="text-muted">Video info: <span class="video-details"></span></small>
                    </div>
                </div>
                <div class="d-flex justify-content-between align-items-center mt-auto button-group">
                    <a href="/recordings/${encodeURIComponent(file)}" 
                       class="btn btn-primary btn-sm me-2 download-button" 
                       download="${file}">
                        <i class="fas fa-download me-1"></i>
                        Download
                    </a>
                    <button class="btn btn-outline-danger btn-sm delete-button" 
                            data-filename="${file}">
                        <i class="fas fa-trash me-1"></i>
                        Delete
                    </button>
                </div>
            </div>
        </div>`;
    
    return col;
}

function createProcessingCard(file) {
    const col = document.createElement('div');
    col.className = 'col-md-6 mb-4';
    
    // Extract timestamp from filename for display - handle new format
    let displayName = file;
    if (file.startsWith('raw_segmented_recording_')) {
        displayName = file.replace('raw_segmented_recording_', 'Segmented Recording ');
    } else if (file.startsWith('Raw Segmented Recording ')) {
        displayName = file.replace('Raw ', '');
    } else if (file.startsWith('raw_')) {
        // Handle other raw formats
        displayName = file.replace('raw_', '').replace('segmented_recording_', 'Segmented Recording ');
    }
    
    // Use the filename as the unique card ID
    const cardId = `processing-${btoa(file).replace(/[^a-zA-Z0-9]/g, '')}`;
    
    col.innerHTML = `
        <div class="card h-100 shadow-sm processing-card" id="${cardId}">
            <div class="card-body d-flex flex-column">
                <h5 class="card-title text-truncate mb-2" title="${displayName}">
                    <i class="fas fa-cog fa-spin me-1"></i>${displayName}
                </h5>
                <div class="processing-preview mb-3 flex-grow-1 d-flex align-items-center justify-content-center">
                    <div class="text-center w-100">
                        <div class="processing-icon mb-3">
                            
                            <div class="spinner-border text-warning" role="status">
                                <span class="visually-hidden">Processing...</span>
                            </div>
                        </div>
                        <h6 class="text-muted mb-2">Processing Video</h6>
                        <p class="small text-muted mb-3">
                            Applying person detection and segmentation...
                        </p>
                        <!-- Enhanced Real Progress Bar with Frame Details -->
                        <div class="progress-container">
                            <div class="d-flex justify-content-between mb-2">
                                <small class="text-muted">Progress</small>
                                <small class="text-muted processing-percentage">Processing...</small>
                            </div>
                            <div class="progress mb-2" style="height: 8px;">
                                <div class="progress-bar progress-bar-striped progress-bar-animated bg-warning" 
                                     role="progressbar" 
                                     style="width: 0%"
                                     aria-valuenow="0" 
                                     aria-valuemin="0"
                                     aria-valuemax="100">
                                </div>
                            </div>
                            <small class="text-muted processing-status">
                                <i class="fas fa-play-circle me-1"></i>
                                Initializing processing...
                            </small>
                            
                            <!-- Frame-by-frame processing details -->
                            <div class="frame-details mt-3" style="display: none;">
                                <div class="row g-2">
                                    <div class="col-6">
                                        <div class="detail-item">
                                            <i class="fas fa-film text-primary me-1"></i>
                                            <span class="detail-label">Frame:</span>
                                            <span class="frame-count">0/0</span>
                                        </div>
                                    </div>
                                    <div class="col-6">
                                        <div class="detail-item">
                                            <i class="fas fa-users text-success me-1"></i>
                                            <span class="detail-label">Detected:</span>
                                            <span class="persons-detected">0</span>
                                        </div>
                                    </div>
                                    <div class="col-6">
                                        <div class="detail-item">
                                            <i class="fas fa-clock text-info me-1"></i>
                                            <span class="detail-label">Speed:</span>
                                            <span class="processing-speed">0.0s/frame</span>
                                        </div>
                                    </div>
                                    <div class="col-6">
                                        <div class="detail-item">
                                            <i class="fas fa-cut text-warning me-1"></i>
                                            <span class="detail-label">SAM:</span>
                                            <span class="sam-time">0.0s</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="d-flex justify-content-center align-items-center mt-auto">
                    <small class="text-muted">
                        <i class="fas fa-clock me-1"></i>
                        Video preview will be available after processing
                    </small>
                </div>
            </div>
        </div>`;
    // Start polling for real progress
    startRealProgressPolling(cardId, file);
    return col;
}

// Poll the backend for real progress and update the progress bar
function startRealProgressPolling(cardId, file) {
    const card = document.getElementById(cardId);
    if (!card) return;
    
    // Get all progress elements
    const progressBar = card.querySelector('.progress-bar');
    const progressPercentage = card.querySelector('.processing-percentage');
    const progressStatus = card.querySelector('.processing-status');
    const frameDetails = card.querySelector('.frame-details');
    const frameCount = card.querySelector('.frame-count');
    const personsDetected = card.querySelector('.persons-detected');
    const processingSpeed = card.querySelector('.processing-speed');
    const samTime = card.querySelector('.sam-time');
    
    let lastPercent = 0;
    let interval = setInterval(() => {
        fetch(`/api/postprocess_progress/${encodeURIComponent(file)}`)
            .then(r => r.json())
            .then(data => {
                console.log('Progress data received:', data); // Debug log
                
                let percent = data.percent || 0;
                let status = data.status || '';
                let frameDetailsData = data.frame_details || {};
                
                console.log('Frame details:', frameDetailsData); // Debug log
                
                // Update main progress bar
                progressBar.style.width = `${percent}%`;
                progressBar.setAttribute('aria-valuenow', percent);
                progressPercentage.textContent = `${percent}%`;
                progressStatus.innerHTML = `<i class="fas fa-cog me-1"></i>${status}`;
                
                // Show and update frame details if available
                if (frameDetailsData && Object.keys(frameDetailsData).length > 0) {
                    console.log('Showing frame details'); // Debug log
                    frameDetails.style.display = 'block';
                    frameDetails.classList.add('active');
                    
                    // Helper function to update value with animation
                    function updateValueWithAnimation(element, newValue) {
                        if (element && element.textContent !== newValue) {
                            element.classList.add('updating');
                            element.textContent = newValue;
                            setTimeout(() => element.classList.remove('updating'), 500);
                        }
                    }
                    
                    // Update frame count
                    if (frameDetailsData.frame_number !== undefined && frameDetailsData.total_frames !== undefined) {
                        updateValueWithAnimation(frameCount, `${frameDetailsData.frame_number}/${frameDetailsData.total_frames}`);
                    }
                    
                    // Update persons detected
                    if (frameDetailsData.persons_detected !== undefined) {
                        updateValueWithAnimation(personsDetected, frameDetailsData.persons_detected.toString());
                    }
                    
                    // Update processing speed
                    if (frameDetailsData.processing_speed !== undefined) {
                        updateValueWithAnimation(processingSpeed, `${frameDetailsData.processing_speed.toFixed(2)}s/frame`);
                    }
                    
                    // Update SAM inference time
                    if (frameDetailsData.sam_inference_time !== undefined) {
                        updateValueWithAnimation(samTime, `${frameDetailsData.sam_inference_time.toFixed(2)}s`);
                    }
                } else {
                    console.log('No frame details available or empty'); // Debug log
                    // Hide frame details if no data available
                    frameDetails.style.display = 'none';
                    frameDetails.classList.remove('active');
                }
                
                lastPercent = percent;
                
                // Check for completion
                if (percent >= 100 || status.toLowerCase().includes('complete') || status.toLowerCase().includes('failed') || status.toLowerCase().includes('error')) {
                    clearInterval(interval);
                    progressBar.classList.remove('progress-bar-animated');
                    progressBar.classList.remove('bg-warning');
                    
                    if (status.toLowerCase().includes('complete')) {
                        progressBar.classList.add('bg-success');
                        progressStatus.innerHTML = `<i class='fas fa-check-circle me-1'></i>Complete`;
                        // Keep frame details visible for completed processing
                    } else if (status.toLowerCase().includes('failed') || status.toLowerCase().includes('error')) {
                        progressBar.classList.add('bg-danger');
                        progressStatus.innerHTML = `<i class='fas fa-times-circle me-1'></i>${status}`;
                        // Hide frame details on error
                        frameDetails.style.display = 'none';
                    }
                    
                    // Optionally, reload the recordings list after a short delay
                    setTimeout(() => { loadRecordingsWithAutoRefresh(); }, 100000);
                }
            })
            .catch((error) => {
                console.warn('Progress polling error:', error);
                // If error, keep showing last known progress
            });
    }, 1500);
}

function deleteRecording(filename) {
    fetch(`/delete_recording/${encodeURIComponent(filename)}`, {
        method: 'DELETE'
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            loadRecordingsWithAutoRefresh(); // Reload the list with auto-refresh
        } else {
            alert('Error deleting recording: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error deleting recording. Please try again.');
    });
}

function handleVideoError(videoElement, filename) {
    console.error('Video error for', filename, ':', videoElement.error);
    console.log('Video source:', videoElement.currentSrc);
    console.log('Video readyState:', videoElement.readyState);
    console.log('Video networkState:', videoElement.networkState);
    console.log('Video duration:', videoElement.duration);
    console.log('Video videoWidth:', videoElement.videoWidth);
    console.log('Video videoHeight:', videoElement.videoHeight);
    
    // Check codec support
    const codecSupport = {
        'H.264 Baseline': videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"'),
        'H.264 Main': videoElement.canPlayType('video/mp4; codecs="avc1.4D401E"'),
        'H.264 High': videoElement.canPlayType('video/mp4; codecs="avc1.64001E"'),
        'Generic MP4': videoElement.canPlayType('video/mp4'),
        'AVI': videoElement.canPlayType('video/x-msvideo')
    };
    
    console.log('Browser codec support:', codecSupport);
    
    // Test if the URL is accessible
    fetch(videoElement.currentSrc)
        .then(response => {
            console.log('Fetch response status:', response.status);
            console.log('Fetch response headers:', response.headers);
            console.log('Fetch response type:', response.type);
            return response.blob();
        })
        .then(blob => {
            console.log('Video blob size:', blob.size);
            console.log('Video blob type:', blob.type);
        })
        .catch(fetchError => {
            console.error('Fetch error:', fetchError);
        });
    
    const errorInfo = videoElement.parentElement.querySelector('.video-error-info');
    const details = videoElement.parentElement.querySelector('.video-details');
    
    let errorMessage = 'Unknown error';
    let isCodecIssue = false;
    
    if (videoElement.error) {
        switch(videoElement.error.code) {
            case 1:
                errorMessage = 'Video loading aborted';
                break;
            case 2:
                errorMessage = 'Network error - cannot load video';
                break;
            case 3:
                errorMessage = 'Video decoding failed - codec not supported by browser';
                isCodecIssue = true;
                break;
            case 4:
                errorMessage = 'Video format not supported by browser';
                isCodecIssue = true;
                break;
        }
    }
    
    console.error(`Video error: ${errorMessage} for file: ${filename}`);
    
    if (details) {
        const supportedCodecs = Object.entries(codecSupport)
            .filter(([_, support]) => support !== '')
            .map(([codec, _]) => codec);
        
        details.textContent = `Error: ${errorMessage}. Supported codecs: ${supportedCodecs.join(', ') || 'None detected'}`;
        errorInfo.style.display = 'block';
    }
    
    // Replace video with error message and test link
    videoElement.style.display = 'none';
    const errorDiv = document.createElement('div');
    errorDiv.className = isCodecIssue ? 'alert alert-warning text-center p-3' : 'alert alert-danger text-center p-3';
    
    const codecHelp = isCodecIssue ? `
        <div class="mt-2 small text-muted">
            <strong>Codec Compatibility Issue:</strong><br>
            Your browser may not support the video codec used in this recording.<br>
            Chrome works best with H.264 baseline profile videos.
        </div>
    ` : '';
    
    errorDiv.innerHTML = `
        <i class="fas fa-exclamation-triangle me-2"></i>
        <strong>Video Playback Error</strong><br>
        <small>${errorMessage}</small><br>
        <small class="text-muted">File: ${filename}</small><br>
        ${codecHelp}
        <div class="mt-2">
            <a href="/recordings/${encodeURIComponent(filename)}" target="_blank" class="btn btn-sm btn-outline-primary me-2">
                Open video in new tab
            </a>
            <button onclick="retryVideoLoad('${filename}', this)" class="btn btn-sm btn-outline-secondary">
                Retry
            </button>
        </div>
    `;
    videoElement.parentElement.appendChild(errorDiv);
}

function handleSourceError(sourceElement, filename, codecType = 'Unknown') {
    console.error(`Source error for ${filename} (${codecType}):`, sourceElement.error);
    console.log(`Failed codec type: ${codecType}, trying next source...`);
}

function handleVideoLoaded(videoElement, filename) {
    console.log('Video metadata loaded for', filename);
    console.log('Duration:', videoElement.duration);
    console.log('Dimensions:', videoElement.videoWidth, 'x', videoElement.videoHeight);
    console.log('Current source:', videoElement.currentSrc);
    
    const errorInfo = videoElement.parentElement.querySelector('.video-error-info');
    const details = videoElement.parentElement.querySelector('.video-details');
    
    if (details) {
        details.textContent = `Duration: ${Math.round(videoElement.duration)}s, Size: ${videoElement.videoWidth}x${videoElement.videoHeight}`;
        errorInfo.style.display = 'block';
    }
}

function handleVideoCanPlay(videoElement, filename) {
    console.log('Video can play:', filename);
}

function retryVideoLoad(filename, buttonElement) {
    console.log('Retrying video load for:', filename);
    
    // Find the video element
    const card = buttonElement.closest('.card');
    const videoContainer = card.querySelector('.video-preview');
    const video = videoContainer.querySelector('video');
    
    if (video) {
        // Show the video element again
        video.style.display = 'block';
        
        // Remove any error divs
        const errorDivs = videoContainer.querySelectorAll('.alert');
        errorDivs.forEach(div => div.remove());
        
        // Reload the video with a new timestamp to avoid caching
        const timestamp = Date.now();
        const sources = video.querySelectorAll('source');
        sources.forEach((source, index) => {
            const originalSrc = source.src.split('?')[0]; // Remove existing timestamp
            source.src = `${originalSrc}?t=${timestamp}`;
            console.log(`Updated source ${index + 1}:`, source.type, source.src);
        });
        
        // Reload the video
        video.load();
    }
}

function testVideoUrl(url) {
    return fetch(url, { method: 'HEAD' })
        .then(response => {
            console.log('Video URL test:', url, 'Status:', response.status);
            console.log('Content-Type:', response.headers.get('content-type'));
            console.log('Content-Length:', response.headers.get('content-length'));
            return response.ok;
        })
        .catch(error => {
            console.error('Video URL test failed:', url, error);
            return false;
        });
}

// Auto-refresh functionality
let refreshInterval;
let progressAnimations = {}; // Track progress animations for each card

function startProgressAnimation(cardId) {
    const card = document.getElementById(cardId);
    if (!card) return;
    
    const progressBar = card.querySelector('.progress-bar');
    const progressPercentage = card.querySelector('.processing-percentage');
    const progressStatus = card.querySelector('.processing-status');
    
    if (!progressBar || !progressPercentage || !progressStatus) return;
    
    let progress = 0;
    const steps = [
        { percent: 15, status: 'Loading models...', icon: 'fas fa-download' },
        { percent: 30, status: 'Analyzing video frames...', icon: 'fas fa-search' },
        { percent: 50, status: 'Detecting persons...', icon: 'fas fa-user-check' },
        { percent: 70, status: 'Applying segmentation...', icon: 'fas fa-cut' },
        { percent: 85, status: 'Processing masks...', icon: 'fas fa-layer-group' },
        { percent: 95, status: 'Finalizing video...', icon: 'fas fa-check-circle' }
    ];
    
    let currentStep = 0;
    
    progressAnimations[cardId] = setInterval(() => {
        if (currentStep < steps.length) {
            const step = steps[currentStep];
            const targetPercent = step.percent;
            
            // Animate to the target percentage
            if (progress < targetPercent) {
                progress += Math.random() * 3 + 1; // Random increment between 1-4
                if (progress > targetPercent) progress = targetPercent;
                
                progressBar.style.width = `${progress}%`;
                progressBar.setAttribute('aria-valuenow', progress);
                progressPercentage.textContent = `${Math.floor(progress)}%`;
            } else {
                // Move to next step
                progressStatus.innerHTML = `<i class="${step.icon} me-1"></i>${step.status}`;
                currentStep++;
            }
        } else {
            // Keep at 95% until actual completion
            if (progress < 95) {
                progress = 95;
                progressBar.style.width = `${progress}%`;
                progressBar.setAttribute('aria-valuenow', progress);
                progressPercentage.textContent = `${Math.floor(progress)}%`;
            }
            progressStatus.innerHTML = `<i class="fas fa-cog fa-spin me-1"></i>Finalizing...`;
        }
    }, 2000 + Math.random() * 1000); // Random interval between 2-3 seconds
}

function stopProgressAnimation(cardId) {
    if (progressAnimations[cardId]) {
        clearInterval(progressAnimations[cardId]);
        delete progressAnimations[cardId];
    }
}

function startAutoRefresh() {
    // Refresh every 5 seconds when there are processing files
    refreshInterval = setInterval(() => {
        fetch('/list_recordings')
            .then(r => r.json())
            .then(data => {
                if (data.processing && data.processing.length > 0) {
                    // Still processing, reload the recordings
                    loadRecordings();
                } else {
                    // No more processing files, stop auto-refresh
                    stopAutoRefresh();
                    loadRecordings(); // Final reload
                }
            })
            .catch(error => {
                console.error('Auto-refresh error:', error);
            });
    }, 5000000);
}

function stopAutoRefresh() {
    if (refreshInterval) {
        clearInterval(refreshInterval);
        refreshInterval = null;
    }
    // Clean up any remaining progress animations
    Object.keys(progressAnimations).forEach(cardId => {
        stopProgressAnimation(cardId);
    });
}

// Enhanced loadRecordings function with auto-refresh
function loadRecordingsWithAutoRefresh() {
    loadRecordings();
    
    // Check if we need to start auto-refresh
    fetch('/list_recordings')
        .then (r => r.json())
        .then(data => {
            if (data.processing && data.processing.length > 0) {
                startAutoRefresh();
            } else {
                stopAutoRefresh();
            }
        });
}

document.addEventListener('DOMContentLoaded', function() {
    // Check codec compatibility on page load
    checkCodecSupport();
    
    // Load recordings
    loadRecordingsWithAutoRefresh();
});
</script>

<style>
/* Section Styling */
.section-container {
    margin-bottom: 2rem;
}

.section-header {
    text-align: center;
    margin-bottom: 2rem;
    padding: 1.5rem 0;
}

.section-title {
    font-size: 1.75rem;
    font-weight: 600;
    color: #2c3e50;
    margin-bottom: 0.5rem;
}

.section-subtitle {
    font-size: 1rem;
    margin-bottom: 0;
}

/* Divider Styling */
.section-divider {
    position: relative;
    margin: 3rem 0;
    text-align: center;
}

.divider-line {
    border: none;
    height: 2px;
    background: linear-gradient(to right, transparent, #dee2e6, transparent);
    margin: 0;
}

.divider-content {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #fff;
    padding: 0 1rem;
    color: #6c757d;
    font-size: 0.8rem;
}

/* Card Type Specific Styling */
.normal-card {
    border-left: 4px solid #007bff;
    transition: transform 0.2s, box-shadow 0.2s;
}

.segmented-card {
    border-left: 4px solid #28a745;
    transition: transform 0.2s, box-shadow 0.2s;
}

.normal-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 0.5rem 1rem rgba(0, 123, 255, 0.15) !important;
}

.segmented-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 0.5rem 1rem rgba(40, 167, 69, 0.15) !important;
}

/* Existing Card Styling */
.card {
    transition: transform 0.2s, box-shadow 0.2s;
    border: none;
}

.card-body {
    padding: 1.5rem;
}

.card-title {
    font-size: 1.15rem;
    color: #343a40;
}

.video-preview {
    background: #f8f9fa;
    border-radius: 6px;
    overflow: hidden;
    position: relative;
    padding-top: 56.25%; /* 16:9 Aspect Ratio */
    margin-bottom: 1rem;
}

.video-preview video {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: contain;
    background: #000;
}

/* Processing Card Styling */
.processing-card {
    border-left: 4px solid #ffc107;
    background: linear-gradient(135deg, #fff9e6 0%, #ffffff 100%);
    border: 1px solid #ffeeba;
}

.processing-preview {
    background: linear-gradient(135deg, #fff9e6 0%, #fffaf0 100%);
    border-radius: 8px;
    min-height: 280px;
    border: 2px dashed #ffc107;
    padding: 1.5rem;
}

.processing-icon {
    position: relative;
    display: inline-block;
}


.progress-container {
    width: 100%;
    max-width: 300px;
    margin: 0 auto;
}

.progress {
    background-color: #f8f9fa;
    border-radius: 4px;
    overflow: hidden;
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
}

.progress-bar {
    transition: width 0.6s ease;
    background: linear-gradient(45deg, #ffc107, #ffed4e);
    position: relative;
    overflow: hidden;
}

.progress-bar-animated::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(
        90deg,
        transparent,
        rgba(255, 255, 255, 0.3),
        transparent
    );
    animation: shine 2s infinite;
}

@keyframes shine {
    0% { left: -100%; }
    100% { left: 100%; }
}

.processing-percentage {
    font-weight: 600;
    color: #856404;
}

.processing-status {
    color: #6c757d;
    font-size: 0.85rem;
    display: block;
    margin-top: 0.5rem;
}

.processing-status i {
    color: #ffc107;
}

/* Button Styling */
.btn {
    font-weight: 500;
    border-radius: 0.375rem;
    padding: 0.5rem 1rem;
    display: inline-flex;
    align-items: center;
}

.download-button {
    background-color: #007bff;
    border-color: #007bff;
    color: #fff;
    box-shadow: 0 2px 4px rgba(0, 123, 255, 0.2);
}

.download-button:hover {
    background-color: #0056b3;
    border-color: #004085;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 123, 255, 0.3);
}

.delete-button {
    background-color: transparent;
    border: 1px solid #dc3545;
    color: #dc3545;
    box-shadow: 0 2px 4px rgba(220, 53, 69, 0.1);
}

.delete-button:hover {
    background-color: #dc3545;
    color: #fff;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(220, 53, 69, 0.2);
}

/* Spacing between buttons */
.button-group .btn:not(:last-child) {
    margin-right: 0.75rem;
}

/* Frame Details Styling */
.frame-details {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-radius: 8px;
    padding: 1rem;
    border: 1px solid #dee2e6;
    margin-top: 1rem;
    transition: all 0.3s ease;
}

.frame-details.active {
    background: linear-gradient(135deg, #e8f4fd 0%, #dbeafe 100%);
    border-color: #3b82f6;
    box-shadow: 0 2px 8px rgba(59, 130, 246, 0.1);
}

.detail-item {
    display: flex;
    align-items: center;
    padding: 0.5rem;
    background: rgba(255, 255, 255, 0.7);
    border-radius: 6px;
    margin-bottom: 0.5rem;
    transition: background-color 0.2s ease;
}

.detail-item:hover {
    background: rgba(255, 255, 255, 0.9);
}

.detail-item:last-child {
    margin-bottom: 0;
}

.detail-label {
    font-weight: 500;
    margin-left: 0.5rem;
    margin-right: 0.5rem;
    color: #495057;
    min-width: 70px;
}

.frame-count,
.persons-detected,
.processing-speed,
.sam-time {
    font-weight: 600;
    color: #212529;
    margin-left: auto;
    font-family: 'Courier New', monospace;
    background: rgba(255, 255, 255, 0.8);
    padding: 0.2rem 0.5rem;
    border-radius: 4px;
    border: 1px solid #e9ecef;
}

/* Icon colors for frame details */
.detail-item .fa-film {
    color: #6f42c1;
}

.detail-item .fa-users {
    color: #28a745;
}

.detail-item .fa-clock {
    color: #17a2b8;
}

.detail-item .fa-cut {
    color: #fd7e14;
}

/* Animation for updating values */
.frame-count.updating,
.persons-detected.updating,
.processing-speed.updating,
.sam-time.updating {
    background: #fff3cd;
    border-color: #ffeaa7;
    animation: pulse-yellow 0.5s ease-in-out;
}

@keyframes pulse-yellow {
    0% { background: #fff3cd; }
    50% { background: #fffadb; }
    100% { background: rgba(255, 255, 255, 0.8); }
}

/* Responsive Design */
.col-md-6 {
    width: 50%;
}

@media (max-width: 768px) {
    .col-md-6 {
        width: 100%;
    }
    
    .section-title {
        font-size: 1.5rem;
    }
    
    .button-group {
        flex-direction: column;
        align-items: stretch;
    }
    
    .button-group .btn {
        margin-right: 0 !important;
        margin-bottom: 0.75rem;
    }
    
    .frame-details .row .col-6 {
        width: 100%;
        margin-bottom: 0.5rem;
    }
    
    .detail-label {
        min-width: 60px;
        font-size: 0.9rem;
    }
}
</style>
{% endblock %}